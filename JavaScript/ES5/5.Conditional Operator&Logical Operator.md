Flow
=====
 컴퓨터가 작동하는 순차적인 흐름을 흐름(Flow)이라고 합니다. 위에서 아래로, 왼쪽에서 오른쪽으로 코드가 하나도 빠지지 않고 차근차근 진행되는 것을 말하죠. 순차적인 흐름을 바꿀 때 제어문(control statement)을 쓰는데 제어문에는 지난 시간에 배운 if문과 switch문과 같은 판단문(conditional statement)이 있었습니다. 그런데 놀라운 사실! 판단문말고도 제어하는 다른 방법이 또 있습니다. 첫번째는 ‘함수’입니다. 함수는 특정한 기능을 수행하는 코드들을 묶어두고 필요하면 언제든지 불러서 쓸 수 있도록 만들어 놓은 것과 같습니다. 함수를 쓰려면 미리 만들어 놔야 하는데(선언), 먼저 함수를 선언해 둔 후 한참 코드를 진행하다가 함수를 쓰려고 부르면(호출) 위에 선언해둔 내용으로 함수의 내용이 실행됩니다. 아래로 흐르고 있었던 흐름이 점프해서 순차적인 흐름을 바뀌게 되었습니다. 흐름을 바꾸는 또 다른 방법은 연산자를 이용하는 방법입니다. 연산자 중에서도 지연을 일으키는 연산자가 있는데, 이 연산자를 이용하면 순차적으로 진행되던 흐름이 잠시 멈춥니다. 멈춘 사이에 일정한 판단을 한 후 특정한 곳으로 이동한다든지, 코드를 건너뛴다든지 등으로 흐름을 변경할 수 있습니다. 대표적인 예로는 우선순위를 강제하는 괄호 연산자()가 있습니다.
 예로 살펴보겠습니다.
 var result = 3 * (2 + 5);
원래의 순차 흐름이라면 왼쪽부터 차근차근 실행되므로 3 * 2가 먼저 실행되어야 합니다. 하지만 괄호 연산자로 인해 순차 흐름이 중단되고 괄호 안의 내용인 2 + 5 의 연산이 먼저 일어나게 됩니다. 그리고 다시 원래의 흐름으로 돌아와 3 * 7이 순차적으로 진행됩니다.
 수학에서 쓰는 () 괄호와 생김새와 내용이 비슷해서 흐름과 상관없이 ‘먼저 계산하는 것’을 너무 당연하게 여겼지만, 컴퓨터 입장에서는 그렇지 않았네요^^
 이처럼 지연을 일으켜서 흐름을 제어하는 연산자에는 괄호연산자 외에도 판단 연산자, 논리 연산자 등이 있습니다. 각각의 연산자를 좀 더 자세하게 살펴보겠습니다.
 
 판단연산자(3항 연산자)
====================
 판단 연산자는 3항 연산자라고도 합니다. (연산자를 기능적으로 구분했을 때에는 판단 연산자, 항의 개수로 분류할 때는 3항 연산자로 분류됩니다.)
 형식은 다음과 같습니다.

 식1 ? 식2 : 식3;
 위 식은 다음과 같은 뜻을 가지고 있습니다.

식1이 거짓이 아니면 식2, 아니면 식3

~이면 a, 아니면 b… 왠지 익숙한 것 같은데… 이전에 배웠던 if-else문이 생각나네요. if-else문과 같은 경우 식이 참이면 if 판단식 이후의 문이, 아니면 else 뒤에 해당하는 문이 실행되었습니다. 이처럼 판단 연산자로 쓴 문장은 if-else문으로 바꿀 수 있고, 그 반대도 가능합니다.

저는 처음에 판단 연산식을 접했을 때에는 형식이 너무 낯설어서 판단 연산식이 눈에 잘 안들어왔습니다. 그래서 처음에는 if문으로만 계속 썼던 기억이…^^;; 익숙해지는데 꽤 많은 시간이 걸렸네요.

그렇다면 (불편함을 제외하고) 어떤 때 판단 연산자를 쓰고 어떤 때 if-else문을 쓸까요?

* 판단 연산자 vs if-else문
우선 형식적으로 판단 연산자와 if-else문의 차이를 살펴보겠습니다.

- 판단 연산자
식1 ? 식2 : 식3;
 
- if-else문
if (식) 문1
else 문2
판단 연산자는 각각의 자리에 ‘식’만 들어갑니다. 하지만 if-else문은 판단 부분에만 ‘식’이, 나머지에는 ‘문’이 들어갑니다. 따라서 if-else문의 결과는 문이 실행되므로 바로 할당이 불가능하지만, 판단 연산자는 연산의 결과로 값이 나오기 때문에 바로 할당이 가능합니다.

- 기온에 따라 폭염주의보인지(33도 이상) 아닌지 판단
var alarm, temp;
 
- if-else문으로 표현
if(temp >= 33) {
  alarm = true;
}else{
  alarm = false;
}
위의 if-else문은 판단을 한 후 ‘alarm=’이란 문을 통해 변수에 true/false값을 할당 합니다. 판단 연산식을 이용하면 판단부터 할당까지 1줄로 할 수 있습니다.

- 판단 연산식으로 표현 (판단부터 할당까지 1줄로 가능)
var alarm = temp >= 33 ?  true : false;
판단 연산식으로 쓰니 중복(‘alarm=’)부분도 많이 제거되고 코드도 한결 간결해진 것 같습니다.

위처럼 상황에 따라 다른 값을 할당해야한다면 if-else문 대신 판단 연산식을 쓰는 편이 좋다고 합니다. 하지만 가끔 판단 후 복잡한 연산을 처리한다든지, 여러가지 문을 실행해야할 때가 있습니다. 그 때에는 if-else문을 이용하는 것이 유리할 수도 있습니다. 이처럼 판단 연산자와 if-else문 중에 어떤 것이 절대적으로 좋으냐를 따질 순 없습니다. 다만 상황에 따라 중복이 적으며, 내가 계획했던 대로 결과가 나오고, 의도를 잘 드러낼 수 있는 방법을 잘 선택할 수 있는 것이 중요한 것 같습니다.

논리 연산자 &&, ||
================
연산 지연을 일으키는 다른 연산자로는 &&, || 연산자가 있습니다. &&, ||은 논리 연산자(Logical Operators)로 좌항과 우항을 논리 연산한 값을 반환해줍니다. 비교논리 연산자에도 여러가지 다양한 종류(>>여기서 확인 가능)가 있지만, 스터디에서는 &&연산자와 ||연산자에 대해 좀 더 깊이 살펴봤습니다.

형식
---
a && b // and 연산자
a || b // or연산자
a && b || c //여러개 연속해서 쓸 수도 있음. 이 경우 연산은 왼쪽에서 오른쪽으로 차근차근 진행

진짜 뜻
------
보통 &&연산자는 두 항이 모두 참이어야 참, || 연산자는 둘 중 하나면 참이라고들 설명합니다. 따라서 각 연산자마다 항의 참/거짓 여부에 따라 나올 수 있는 결과의 경우는 4가지씩 됩니다.

&&연산자 결과의 경우의 수는 다음과 같습니다.

* 참 && 거짓 = 거짓
* 참 && 참 = 참
* 거짓 && 참 = 거짓
* 거짓 && 거짓 = 거짓

자세히 보면 첫번째 항이 참인 경우에는 뒤의 두번째 항이 결과가 되고, 첫번째 항이 거짓이면 첫번째 항의 값이 됩니다. 즉, &&연산자의 결과는 첫번째 항이 거짓이면 첫번째 항, 아니면 두번째 항이라는 것을 알 수 있습니다.

이 원리를 이용하면 두 항을 모두 보지 않고 첫번째 항의 값만 보고도 결과를 판단할 수 있습니다. 예로 살펴보겠습니다.

0 && 'aaa'; //0
위 예시에서 첫번째 항인 0은 JavaScript에서 거짓으로 처리가 되어 거짓이 됩니다. 따라서 뒤의 항 ‘aaa’를 갈 필요도 없이 결과는 0이 됩니다.

'aaa' && 'bbb'; //"bbb"
'aaa' && 0; //0
첫번째 항이 참인 경우에는 두번째 항이 참이냐 거짓이냐는 결과에 영향을 미치지 않습니다. 따라서 ‘aaa’ && ‘bbb’ 처럼 두번째 항이 참인 경우도, ‘aaa’ && 0 처럼 두번째 항이 거짓인 경우도 첫번째 항인 ‘aaa’가 모두 참이므로 모두 결과는 두번째 항이 됩니다.

즉, &&연산자를 만났을 때 flow는 이렇게 된다고 볼 수 있을 것 같습니다.
